# 编程题

打印 `#`

```js
function printStr() {
  var str = ''

  for (let i = 0; i < 8; i++) {
    str += '#'
    console.log(str)
  }
}
```

打印从 1-100 之间的数组，如果数字被 3 整除，不打印数字，打印 Bizz, 如果数字被 5 整除，打印 Fuzz。如果同时被 3 和 5 整除，打印 BizzFuzz

```js
function printNumber() {
  for (let i = 1; i <= 100; i++) {
    let output = ''
    if (i % 3 === 0) output += 'Bizz'
    if (i % 5 === 0) output += 'Fuzz'
    // console.log(output || i)
  }
}
```

错峰打印 `#` 字

```js
function print(size) {
  size = size || 8
  let str = ''
  for (let i = 0; i < size; i++) {
    for (let j = 0; j < size; j++) {
      if ((i + j) % 2 === 0) {
        str += '#'
      } else {
        str += ' '
      }
    }
    str += '\n'
  }
  console.log(str)
}
print(16)
```

```js
var power = function(base, exponent) {
  let result = 1
  for (let i = 0; i < exponent; i++) {
    result *= base
  }
  return result
}
console.log(power(2, 10))
```

// 作用域

```js
function wrapValue(val) {
  var localVal = val
  return function() {
    return localVal
  }
}

var wrap1 = wrapValue(1)
var wrap2 = wrapValue(2)

console.log(wrap1()) // 1
console.log(wrap2()) // 2

function mutipler(factor) {
  return function(number) {
    return number * factor
  }
}

var twice = mutipler(2)

console.log(twice(5))

function power(base, exponent) {
  if (exponent == 0) {
    return 1
  }
  return base * power(base, exponent - 1)
}

console.log(power(2, 5))
```

```js
// var journal = [
//   {
//     squirrel: false,
//     events: ['work', 'touched', 'pizza', 'running', 'television']
//   },
//   {
//     squirrel: false,
//     events: ['work', 'ice cream', 'cauliflower', 'lasagna', 'touched tree', 'brushed teeth']
//   },
//   {
//     squirrel: true,
//     events: ['weekend', 'cycling', 'break', 'peanuts', 'beer']
//   },
// ]

var JOURNAL = []
function addEntry(events, doSomeing) {
  JOURNAL.push({ events: events, squirrel: doSomeing })
}

addEntry(false, 'work', 'touched', 'pizza', 'running', 'television')
addEntry(
  false,
  'work',
  'ice cream',
  'cauliflower',
  'lasagna',
  'touched tree',
  'brushed teeth'
)
addEntry(true, 'weekend', 'cycling', 'break', 'peanuts', 'beer')

function addEntry(squirrel) {
  var entry = { events: [], squirrel: squirrel }

  for (let i = 1; i < arguments.length; i++) {
    entry.events.push(arguments[i])
  }

  JOURNAL.push(entry)
}

function phi(table) {
  return (
    (table[3] * table[0] - table[2] * table[1]) /
    Math.sqrt(
      (table[2] + table[3]) *
        (table[0] + table[1]) *
        (table[1] + table[3]) *
        (table[0] + table[2])
    )
  )
}

function hasEvent(event, entry) {
  return entry.events.indexOf(event) !== -1
}

function tableFor(event, journal) {
  var table = [0, 0, 0, 0]
  for (let i = 0; i < journal.length; i++) {
    var entry = journal[i]
    var index = 0

    if (hasEvent(event, entry)) {
      index += 1
    }

    if (entry.squirrel) {
      index += 2
    }
    table[index] += 1
  }
  return table
}

function gatherCorrelations(journal) {
  var phis = {}
  for (let entry = 0; entry < journal.length; entry++) {
    var events = journal[entry].events

    for (let i = 0; i < events.length; i++) {
      var event = events[i]
      if (!(event in phis)) {
        phis[event] = phi(tableFor(event, journal))
      }
    }
  }
  return phis
}

var correlations = gatherCorrelations(JOURNAL)

for (var event in correlations) {
  console.log(event + ': ' + correlations[event])
}
```

## 第五章 高阶函数

抽象代码

```js
function logEach(array) {
  for (let i = 0; i < array.length; i++) {
    console.log(array[i])
  }
}

function forEach(array, callback) {
  for (let i = 0; i < array.length; i++) {
    callback(array[i])
  }
}
```

```js
function noisy(f) {
  return function(args) {
    var val = f(args)

    return val
  }
}
```

```js
function unless(test, then) {
  if (test) then()
}

function repeat(time, body) {
  for (let i = 0; i < time; i++) {
    body(i)
  }
}

repeat(4, function(i) {
  unless(!(i % 2), function() {
    console.log('is even')
  })
})
```

filter 函数

```js
function filter(array, test) {
  let result = []
  for (let i = 0; i < array.length; i++) {
    if (test(array[i])) {
      result.push(array[i])
    }
  }
  return result
}
```

map 函数

```js
function map(array, transform) {
  let mapped = []
  for (let i = 0; i < array.length; i++) {
    mapped.push(transform[array[i]])
  }
  return mapped
}
```

reduce 函数

```js
function myReduce(array, combine, start) {
  let current = start

  for (let i = 0; i < array.length; i++) {
    current = combine(current, array[i])
  }

  return current
}
```

使用 reduce 函数计算平均值

```js
function average(array) {
  const plus = (a, b) => a + b

  return myReduce(plus) / array.length
}

function age(p) {
  return p.died - p.born
}

function male(p) {
  return p.sex == 'm'
}

function female(p) {
  return p.sex == 'f'
}

var byName = {}
ancestry.forEach(function(p) {
  byName[p.name] = person
})

function reduceAcestors(person, f, defaultValue) {
  function valueFor(person) {
    if (person == null) {
      return defaultValue
    } else {
      return f(
        person,
        valueFor(byName[person.father]),
        valueFor(byName[person.mother])
      )
    }
  }
  return valueFor(person)
}

function countAncestors(person, test) {
  function combine(person, fromFather, fromMather) {
    let thisOneCount = test(person)
    return fromFather + fromMather + (thisOneCount ? 1 : 0)
  }
  return reduceAcestors(person, combine, 0)
}

function longLivePerson(person) {
  let all = countAncestors(person, function(person) {
    return true
  })

  let longLiving = countAncestors(person, function(person) {
    return person.died - person.born >= 70
  })

  return longLiving / all
}
```

## 第六章 对象

### 绘制表格

计算每行的最大高度

```js
function rowHeights(rows) {
  return rows.map(row => {
    return row.reduce((max, cell) => {
      return Math.max(max, cell.minHeight())
    }, 0)
  })
}
```

计算每列的最小宽度

```js
function colWidths(rows) {
  return rows[0].map((_, i) => {
    return rows.reduce((max, row) => {
      return Math.max(max, row[i].minWidth())
    })
  })
}
```

绘制表格

```js
function drawTable(rows) {
  const heights = rowHeights(rows)
  const widths = colWidths(rows)

  const drawLine = (blocks, lineNo) => blocks.map(block => block[lineNo]).join(' ')

  const drawRow = (row, rowNum) => {
    const blocks = row.map((cell, colNum) => cell.draw(widths[colNum], heights[rowNum]))

    return blocks[0].map((_, lineNo) => drawLine(blocks, lineNo)).join('\n')
  }
  
  return rows.map(drawRow).join('\n')
}
```

绘制单元格

```js
// 辅助函数
function repeat(string, times) {
  let result = ''
  for (let i = 0; i < times; i++) {
    result += string
  }
  return result
}

function TextCell(text) {
  this.text = text.split('\n')
}

TextCell.prototype.minWidth = function() {
  return this.text.reduce((width, line) => Math.max(width, line.length)
  , 0)
}

TextCell.prototype.minHeight = function() {
  return this.text.length
}

TextCell.prototype.draw = function(width, height) {
  let result = []

  for (let i = 0; i < height; i++) {
    const line = this.text[i] || ''
    result.push(`${line}${repeat(' ', width - line.length)}`)
  }
  return result
}
```

添加下划线

```js
function UnderlineCell(inner) {
  this.inner = inner
}

UnderlineCell.prototype.minWidth = function() {
  return this.inner.minWidth()
}

UnderlineCell.prototype.minHeight = function() {
  return this.inner.minHeight() + 1
}

UnderlineCell.prototype.draw = function(width, height) {
  return this.inner.draw(width, height -1).concat([repeat('-', width)])
}
```

draw 表格数据

```js
function dataTable(data) {
  const keys = Object.keys(data[0])
  const headers = keys.map(name => {
    return new UnderlineCell(new TextCell(name))
  })

  const body = data.map(row => {
    return keys.map(name => {
      return new TextCell(String(row[name]))
    })
  })

  return headers.concat(body)
}
```

表格居右对齐

```js
// 继承 TextCell
function RTextCell(text) {
  TextCell.call(this, text)
}

RTextCell.prototype = Object.create(TextCell.prototype)

RTextCell.prototype.draw = function(width, height) {
  const result = []

  for (let i = 0; i < height; i++) {
    const line = this.text[i] || ''
    result.push(repeat(' ', width - line.length) + line)
  }
  return result
}
```

## Grid 函数

```js
function Grid(width, height) {
  this.space = width * height
  this.width = width
  this.height = height
}

Grid.prototype.isInside = function(vector) {
  const { x, y } = vector
  return x > 0 && x < this.width && y > 0 && y < this.height
}

Grid.prototype.get = function(vector) {
  return this.space[vector.x + this.width * vector.y]
}

Grid.prototype.set = function(vector, value) {
  this.space[vector.x + this.width * vector.y] = value
}

Grid.prototype.forEach = function(fn, ctx) {
  for (let y = 0; y < this.grid.height; y++) {
    for (let x = 0; x < this.grid.width; x++) {
      const value = this.space[x + y * this.width]
      fn.call(ctx, value, new Vector(x, y))
    }
  }
}
```

方位对象

```js
const directions = {
  'n': new Vector(0, -1),
  'ne': new Vector(1, -1),
  'e': new Vector(1, 0),
  'se': new Vector(1, 1),
  's': new Vector(0, 1),
  'sw': new Vector(-1, 1),
  'w': new Vector(-1, 0),
  'nw': new Vector(-1, -1),
}
```

随机方向爬行函数

```js
function randomElement(array) {
  return array[Math.floor(Math.random() * array.length)]
}

const directionNames = 'n ne e se s sw w nw'.split(' ')

function BouncingCritter() {
  this.direction = randomElement(directionNames)
}

BouncingCritter.prototype.act = function(view) {
  if (view.look(this.direction) != ' ') {
    this.direction = view.find(' ') || 's'
    return { type: 'move', direction: this.direction }
  }
}
```

world 对象

```js
function elementFromChar(legend, ch) {
  if (ch == '') return null
  let element = new legend[ch]()
  element.originChar = ch
  return element
}

function World(map, legend) {
  const grid = new Grid(map[0].length, map.length)
  this.grid = grid
  this.legend = legend

  map.forEach((line, y) => {
    for (let x = 0; x < line.length; x++) {
      grid.set(new Vector(x, y), elementFromChar(legend, line[x]))
    }
  })
}

World.prototype.toString = function() {
  let output = ''

  for (let y = 0; y < this.grid.height; y++) {
    for (let x = 0; x < this.grid.width; x++) {
      const element = this.get(new Vector(x, y))
      output += charFromElement(element)
    }
  }

  return output
}

World.prototype.turn = function() {
  let acted = []
  this.grid.forEach((critter, vector) => {
    if (critter.act && acted.indexOf(critter) == -1) {
      acted.push(critter)
      this.letAct(critter, vector)
    }
  }, this)
}

World.prototype.letAct = function(critter, vector) {
  let action = critter.act(new View(this, vector))
  if (action && action.type == 'move') {
    const dest = this.checkDestination(action, vector)
    if (dest && this.grid.get(dest) == null) {
      this.grid.set(vector, null)
      this.grid.set(dest, critter)
    }
  }
}

World.prototype.checkDestination = function(action, vector) {
  if (directions.hasOwnProperty(action.direction)) {
    const dest = vector.plus(directions[action.direction])
    return dest
  }
}


function charFromElement(element) {
  if (element == null) return ''
  else
    return element.originChar
}

function Wall() {

}

function View(world, vector) {
  this.world = world
  this.vector = vector
}

View.prototype.look = function(dir) {
  const target = this.vector.plus(directions[dir])
  if (this.world.grid.isInside(target)) {
    return charFromElement(this.world.grid.get(target))
  } else {
    return '#'
  }
}

View.prototype.find = function(ch) {
  const found = this.findAll(ch)
  if (found.length == 0) return null
  return randomElement(found)
}

View.prototype.findAll = function(ch) {
  const found = []
  for (let dir in directions) {
    if (this.view(dir) == ch) {
      found.push(dir)
    }
  }
  return found
}


for (let i = 0; i < 5; i++) {
  world.turn()
  console.log(world.toString())
}

```

## 第八章 错误捕获

### 自定义错误类型

```js
function InputError(message) {
  this.message = message
  this.stack = (new Error()).stack
}

InputError.prototype = Object.create(Error.prototype)
InputError.prototype.name = 'InputError'
```

### 断言

```js
function AssertionFailed(message) {
  this.message = message
}

AssertionFailed.prototype = Object.create(Error.prototype)

function assert(test, message) {
  if (!test) throw new AssertionFailed(message)
}

function lastElement(array) {
  assert(array.length > 0, 'empty array in lastElement')
  return array[array.length - 1]
}
```

## 正则表达式
